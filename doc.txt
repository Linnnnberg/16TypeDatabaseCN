doc 
this the source code generated by claude
# requirements.txt
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
alembic==1.12.1
psycopg2-binary==2.9.9
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
jinja2==3.1.2
python-dotenv==1.0.0
redis==5.0.1
email-validator==2.1.0
pydantic==2.5.0
pydantic-settings==2.1.0

# .env
DATABASE_URL=postgresql://username:password@localhost/mbti_roster
SECRET_KEY=your-super-secret-key-here
REDIS_URL=redis://localhost:6379
EMAIL_FROM=noreply@mbti-roster.com

# app/core/config.py
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    database_url: str
    secret_key: str
    redis_url: str = "redis://localhost:6379"
    email_from: str = "noreply@mbti-roster.com"
    
    # 投票限制配置
    daily_vote_limit: int = 20
    daily_no_reason_limit: int = 5
    new_user_24h_limit: int = 3
    daily_registrations_per_ip: int = 3
    
    class Config:
        env_file = ".env"

settings = Settings()

# app/core/security.py
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import HTTPException, status
from .config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.secret_key, algorithm="HS256")
    return encoded_jwt

def verify_token(token: str) -> dict:
    try:
        payload = jwt.decode(token, settings.secret_key, algorithms=["HS256"])
        return payload
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        )

# app/database/models.py
from sqlalchemy import Column, Integer, String, DateTime, Text, Boolean, ForeignKey, Date, Enum as SQLEnum, Index
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from enum import Enum
import uuid

Base = declarative_base()

class UserRole(str, Enum):
    SYSTEM = "SYSTEM"
    CLIENT = "CLIENT"

class MBTIType(str, Enum):
    INTJ = "INTJ"
    INTP = "INTP"
    ENTJ = "ENTJ"
    ENTP = "ENTP"
    INFJ = "INFJ"
    INFP = "INFP"
    ENFJ = "ENFJ"
    ENFP = "ENFP"
    ISTJ = "ISTJ"
    ISFJ = "ISFJ"
    ESTJ = "ESTJ"
    ESFJ = "ESFJ"
    ISTP = "ISTP"
    ISFP = "ISFP"
    ESTP = "ESTP"
    ESFP = "ESFP"

class User(Base):
    __tablename__ = "users"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    name = Column(String, nullable=False)
    role = Column(SQLEnum(UserRole), default=UserRole.CLIENT)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # 关系
    votes = relationship("Vote", back_populates="user")
    comments = relationship("Comment", back_populates="user")
    daily_stats = relationship("DailyUserStats", back_populates="user")

class Celebrity(Base):
    __tablename__ = "celebrities"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    name = Column(String, nullable=False, index=True)
    name_en = Column(String)
    description = Column(Text)
    image_url = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # 关系
    votes = relationship("Vote", back_populates="celebrity")
    comments = relationship("Comment", back_populates="celebrity")
    tags = relationship("CelebrityTag", back_populates="celebrity")

class Tag(Base):
    __tablename__ = "tags"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    name = Column(String, unique=True, nullable=False)
    description = Column(Text)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # 关系
    celebrities = relationship("CelebrityTag", back_populates="tag")

class CelebrityTag(Base):
    __tablename__ = "celebrity_tags"
    
    celebrity_id = Column(String, ForeignKey("celebrities.id"), primary_key=True)
    tag_id = Column(String, ForeignKey("tags.id"), primary_key=True)
    
    # 关系
    celebrity = relationship("Celebrity", back_populates="tags")
    tag = relationship("Tag", back_populates="celebrities")

class Vote(Base):
    __tablename__ = "votes"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String, ForeignKey("users.id"), nullable=False)
    celebrity_id = Column(String, ForeignKey("celebrities.id"), nullable=False)
    mbti_type = Column(SQLEnum(MBTIType), nullable=False)
    reason = Column(Text)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # 关系
    user = relationship("User", back_populates="votes")
    celebrity = relationship("Celebrity", back_populates="votes")
    
    # 唯一约束
    __table_args__ = (
        Index('ix_user_celebrity_vote', 'user_id', 'celebrity_id', unique=True),
    )

class Comment(Base):
    __tablename__ = "comments"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String, ForeignKey("users.id"), nullable=False)
    celebrity_id = Column(String, ForeignKey("celebrities.id"), nullable=False)
    content = Column(Text, nullable=False)
    parent_id = Column(String, ForeignKey("comments.id"))
    level = Column(Integer, default=1)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # 关系
    user = relationship("User", back_populates="comments")
    celebrity = relationship("Celebrity", back_populates="comments")
    parent = relationship("Comment", remote_side=[id])
    replies = relationship("Comment", back_populates="parent")

class DailyUserStats(Base):
    __tablename__ = "daily_user_stats"
    
    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String, ForeignKey("users.id"), nullable=False)
    date = Column(Date, nullable=False)
    votes_count = Column(Integer, default=0)
    votes_no_reason = Column(Integer, default=0)
    
    # 关系
    user = relationship("User", back_populates="daily_stats")
    
    # 唯一约束
    __table_args__ = (
        Index('ix_user_date_stats', 'user_id', 'date', unique=True),
    )

# app/database/database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.core.config import settings
from app.database.models import Base

engine = create_engine(settings.database_url)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def create_tables():
    Base.metadata.create_all(bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# app/schemas/user.py
from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime
from app.database.models import UserRole

class UserBase(BaseModel):
    email: EmailStr
    name: str

class UserCreate(UserBase):
    password: str

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class User(UserBase):
    id: str
    role: UserRole
    is_active: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    email: Optional[str] = None

# app/schemas/celebrity.py
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime
from app.database.models import MBTIType

class TagBase(BaseModel):
    name: str
    description: Optional[str] = None

class Tag(TagBase):
    id: str
    created_at: datetime
    
    class Config:
        from_attributes = True

class CelebrityBase(BaseModel):
    name: str
    name_en: Optional[str] = None
    description: Optional[str] = None
    image_url: Optional[str] = None

class CelebrityCreate(CelebrityBase):
    tag_names: Optional[List[str]] = []

class VoteStats(BaseModel):
    mbti_type: MBTIType
    count: int

class Celebrity(CelebrityBase):
    id: str
    created_at: datetime
    vote_stats: List[VoteStats] = []
    tags: List[Tag] = []
    total_votes: int = 0
    total_comments: int = 0
    
    class Config:
        from_attributes = True

# app/schemas/vote.py
from pydantic import BaseModel
from typing import Optional
from datetime import datetime
from app.database.models import MBTIType

class VoteBase(BaseModel):
    mbti_type: MBTIType
    reason: Optional[str] = None

class VoteCreate(VoteBase):
    celebrity_id: str

class Vote(VoteBase):
    id: str
    user_id: str
    celebrity_id: str
    created_at: datetime
    
    class Config:
        from_attributes = True

# app/schemas/comment.py
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime

class CommentBase(BaseModel):
    content: str

class CommentCreate(CommentBase):
    celebrity_id: str
    parent_id: Optional[str] = None

class Comment(CommentBase):
    id: str
    user_id: str
    celebrity_id: str
    parent_id: Optional[str]
    level: int
    created_at: datetime
    user_name: str
    replies: List['Comment'] = []
    
    class Config:
        from_attributes = True

# app/services/auth.py
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from fastapi import HTTPException, status
from app.database.models import User
from app.schemas.user import UserCreate
from app.core.security import get_password_hash, verify_password, create_access_token

class AuthService:
    def __init__(self, db: Session):
        self.db = db
    
    def create_user(self, user_create: UserCreate) -> User:
        # 检查用户是否已存在
        existing_user = self.db.query(User).filter(User.email == user_create.email).first()
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="邮箱已被注册"
            )
        
        # 创建新用户
        hashed_password = get_password_hash(user_create.password)
        db_user = User(
            email=user_create.email,
            name=user_create.name,
            hashed_password=hashed_password
        )
        self.db.add(db_user)
        self.db.commit()
        self.db.refresh(db_user)
        return db_user
    
    def authenticate_user(self, email: str, password: str) -> User:
        user = self.db.query(User).filter(User.email == email).first()
        if not user or not verify_password(password, user.hashed_password):
            return None
        return user
    
    def create_access_token_for_user(self, user: User) -> str:
        access_token_expires = timedelta(days=7)
        return create_access_token(
            data={"sub": user.email}, expires_delta=access_token_expires
        )

# app/services/vote.py
from datetime import date
from sqlalchemy.orm import Session
from sqlalchemy import func
from fastapi import HTTPException, status
from app.database.models import Vote, DailyUserStats, User
from app.schemas.vote import VoteCreate
from app.core.config import settings

class VoteService:
    def __init__(self, db: Session):
        self.db = db
    
    def check_vote_permission(self, user_id: str, has_reason: bool) -> dict:
        today = date.today()
        
        # 获取或创建今日统计
        stats = self.db.query(DailyUserStats).filter(
            DailyUserStats.user_id == user_id,
            DailyUserStats.date == today
        ).first()
        
        if not stats:
            stats = DailyUserStats(user_id=user_id, date=today)
            self.db.add(stats)
            self.db.commit()
            self.db.refresh(stats)
        
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            return {"allowed": False, "message": "用户不存在"}
        
        # 检查新用户24小时限制
        is_new_user = (date.today() - user.created_at.date()).days < 1
        if is_new_user and stats.votes_count >= settings.new_user_24h_limit:
            return {"allowed": False, "message": "新用户24小时内只能投票3次"}
        
        # 检查每日总投票限制
        if stats.votes_count >= settings.daily_vote_limit:
            return {"allowed": False, "message": "每日投票次数已达上限"}
        
        # 检查无理由投票限制
        if not has_reason and stats.votes_no_reason >= settings.daily_no_reason_limit:
            return {"allowed": False, "message": "每日无理由投票次数已达上限"}
        
        return {"allowed": True}
    
    def create_vote(self, user_id: str, vote_create: VoteCreate) -> Vote:
        # 检查是否已经投过票
        existing_vote = self.db.query(Vote).filter(
            Vote.user_id == user_id,
            Vote.celebrity_id == vote_create.celebrity_id
        ).first()
        
        if existing_vote:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="您已经为这个人物投过票了"
            )
        
        # 检查投票权限
        has_reason = bool(vote_create.reason and vote_create.reason.strip())
        permission = self.check_vote_permission(user_id, has_reason)
        
        if not permission["allowed"]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=permission["message"]
            )
        
        # 创建投票
        vote = Vote(
            user_id=user_id,
            celebrity_id=vote_create.celebrity_id,
            mbti_type=vote_create.mbti_type,
            reason=vote_create.reason
        )
        self.db.add(vote)
        
        # 更新统计
        today = date.today()
        stats = self.db.query(DailyUserStats).filter(
            DailyUserStats.user_id == user_id,
            DailyUserStats.date == today
        ).first()
        
        stats.votes_count += 1
        if not has_reason:
            stats.votes_no_reason += 1
        
        self.db.commit()
        self.db.refresh(vote)
        return vote

# app/services/celebrity.py
from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import func, desc
from app.database.models import Celebrity, Tag, CelebrityTag, Vote, Comment
from app.schemas.celebrity import CelebrityCreate, VoteStats

class CelebrityService:
    def __init__(self, db: Session):
        self.db = db
    
    def create_celebrity(self, celebrity_create: CelebrityCreate) -> Celebrity:
        # 创建名人
        celebrity = Celebrity(
            name=celebrity_create.name,
            name_en=celebrity_create.name_en,
            description=celebrity_create.description,
            image_url=celebrity_create.image_url
        )
        self.db.add(celebrity)
        self.db.flush()  # 获取ID但不提交
        
        # 处理标签
        for tag_name in celebrity_create.tag_names:
            tag = self.db.query(Tag).filter(Tag.name == tag_name).first()
            if not tag:
                tag = Tag(name=tag_name)
                self.db.add(tag)
                self.db.flush()
            
            celebrity_tag = CelebrityTag(celebrity_id=celebrity.id, tag_id=tag.id)
            self.db.add(celebrity_tag)
        
        self.db.commit()
        self.db.refresh(celebrity)
        return celebrity
    
    def get_celebrities(self, skip: int = 0, limit: int = 12) -> List[Celebrity]:
        celebrities = self.db.query(Celebrity).offset(skip).limit(limit).all()
        
        # 为每个名人添加投票统计和标签
        for celebrity in celebrities:
            celebrity.vote_stats = self.get_vote_stats(celebrity.id)
            celebrity.total_votes = sum(stat.count for stat in celebrity.vote_stats)
            celebrity.total_comments = self.db.query(Comment).filter(
                Comment.celebrity_id == celebrity.id
            ).count()
        
        return celebrities
    
    def get_celebrity_by_id(self, celebrity_id: str) -> Optional[Celebrity]:
        celebrity = self.db.query(Celebrity).filter(Celebrity.id == celebrity_id).first()
        if celebrity:
            celebrity.vote_stats = self.get_vote_stats(celebrity.id)
            celebrity.total_votes = sum(stat.count for stat in celebrity.vote_stats)
            celebrity.total_comments = self.db.query(Comment).filter(
                Comment.celebrity_id == celebrity.id
            ).count()
        return celebrity
    
    def get_vote_stats(self, celebrity_id: str) -> List[VoteStats]:
        stats = self.db.query(
            Vote.mbti_type,
            func.count(Vote.id).label('count')
        ).filter(
            Vote.celebrity_id == celebrity_id
        ).group_by(Vote.mbti_type).all()
        
        return [VoteStats(mbti_type=stat.mbti_type, count=stat.count) for stat in stats]
    
    def search_celebrities(self, query: str, limit: int = 10) -> List[Celebrity]:
        celebrities = self.db.query(Celebrity).filter(
            Celebrity.name.ilike(f"%{query}%")
        ).limit(limit).all()
        
        for celebrity in celebrities:
            celebrity.vote_stats = self.get_vote_stats(celebrity.id)
            celebrity.total_votes = sum(stat.count for stat in celebrity.vote_stats)
        
        return celebrities

# app/api/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.database.database import get_db
from app.schemas.user import UserCreate, UserLogin, User, Token
from app.services.auth import AuthService

router = APIRouter(prefix="/auth", tags=["authentication"])

@router.post("/signup", response_model=User)
def signup(user_create: UserCreate, db: Session = Depends(get_db)):
    auth_service = AuthService(db)
    return auth_service.create_user(user_create)

@router.post("/login", response_model=Token)
def login(user_login: UserLogin, db: Session = Depends(get_db)):
    auth_service = AuthService(db)
    user = auth_service.authenticate_user(user_login.email, user_login.password)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="邮箱或密码错误",
        )
    
    access_token = auth_service.create_access_token_for_user(user)
    return {"access_token": access_token, "token_type": "bearer"}

# app/api/celebrities.py
from typing import List
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from app.database.database import get_db
from app.schemas.celebrity import Celebrity, CelebrityCreate
from app.services.celebrity import CelebrityService

router = APIRouter(prefix="/celebrities", tags=["celebrities"])

@router.get("/", response_model=List[Celebrity])
def get_celebrities(
    skip: int = Query(0, ge=0),
    limit: int = Query(12, ge=1, le=100),
    db: Session = Depends(get_db)
):
    celebrity_service = CelebrityService(db)
    return celebrity_service.get_celebrities(skip=skip, limit=limit)

@router.get("/search", response_model=List[Celebrity])
def search_celebrities(
    q: str = Query(..., min_length=1),
    limit: int = Query(10, ge=1, le=50),
    db: Session = Depends(get_db)
):
    celebrity_service = CelebrityService(db)
    return celebrity_service.search_celebrities(query=q, limit=limit)

@router.get("/{celebrity_id}", response_model=Celebrity)
def get_celebrity(celebrity_id: str, db: Session = Depends(get_db)):
    celebrity_service = CelebrityService(db)
    celebrity = celebrity_service.get_celebrity_by_id(celebrity_id)
    if not celebrity:
        raise HTTPException(status_code=404, detail="人物不存在")
    return celebrity

@router.post("/", response_model=Celebrity)
def create_celebrity(
    celebrity_create: CelebrityCreate,
    db: Session = Depends(get_db)
):
    celebrity_service = CelebrityService(db)
    return celebrity_service.create_celebrity(celebrity_create)

# app/api/votes.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.database.database import get_db
from app.schemas.vote import VoteCreate, Vote
from app.services.vote import VoteService
from app.core.auth import get_current_user
from app.database.models import User

router = APIRouter(prefix="/votes", tags=["votes"])

@router.post("/", response_model=Vote)
def create_vote(
    vote_create: VoteCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    vote_service = VoteService(db)
    return vote_service.create_vote(current_user.id, vote_create)

# app/core/auth.py
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from app.database.database import get_db
from app.database.models import User
from app.core.security import verify_token

security = HTTPBearer()

def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    token = credentials.credentials
    payload = verify_token(token)
    email = payload.get("sub")
    
    if email is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
        )
    
    user = db.query(User).filter(User.email == email).first()
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
        )
    
    return user

# app/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from app.database.database import create_tables
from app.api import auth, celebrities, votes

# 创建FastAPI应用
app = FastAPI(
    title="16型花名册",
    description="MBTI人格类型数据库API",
    version="1.0.0"
)

# CORS中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 生产环境中应该指定具体的域名
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 静态文件和模板
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# 注册路由
app.include_router(auth.router, prefix="/api")
app.include_router(celebrities.router, prefix="/api")
app.include_router(votes.router, prefix="/api")

# 启动时创建数据库表
@app.on_event("startup")
def startup_event():
    create_tables()

# 根路径
@app.get("/")
def read_root():
    return {"message": "欢迎使用16型花名册API"}

# 健康检查
@app.get("/health")
def health_check():
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=True)

# alembic.ini
[alembic]
script_location = alembic
prepend_sys_path = .
version_path_separator = os
sqlalchemy.url = postgresql://username:password@localhost/mbti_roster

[post_write_hooks]

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

# docker-compose.yml
version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: mbti_user
      POSTGRES_PASSWORD: mbti_password
      POSTGRES_DB: mbti_roster
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  app:
    build: .
    ports:
      - "8000:8000"
    depends_on:
      - db
      - redis
    environment:
      DATABASE_URL: postgresql://mbti_user:mbti_password@db/mbti_roster
      REDIS_URL: redis://redis:6379
    volumes:
      - .:/app
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

volumes:
  postgres_data:

# Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

# 启动脚本 - run.py
#!/usr/bin/env python3
"""
快速启动脚本
"""
import subprocess
import sys
import os

def install_dependencies():
    """安装依赖"""
    print("正在安装Python依赖...")
    subprocess.run([sys.executable, "-m", "pip", "install", "-r", "requirements.txt"])

def setup_database():
    """设置数据库"""
    print("正在设置数据库...")
    # 这里可以添加数据库初始化逻辑
    pass

def run_server():
    """启动服务器"""
    print("启动FastAPI服务器...")
    subprocess.run([
        "uvicorn", 
        "